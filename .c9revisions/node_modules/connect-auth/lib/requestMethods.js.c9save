{"ts":1350572922564,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * Copyright(c) 2010 Ciaran Jessup <ciaranj@gmai.com>\n * MIT Licensed\n */\n \n/* \n * This file contains the methods that will become 'mixed-in' with the connect request object, namely:\n * \n *   authenticate( [strategy|options], callback(err, succcessFailOngoing) )\n *   getAuthDetails\n *   isAuthenticated( [scope] )\n *   isUnAuthenticated( [scope] )\n *   logout( [scope], [callback(err)])\n */\nmodule.exports.authenticate= function(strategy, opts, callback, strategyExecutor, res, firstLoginHandler) {\n   var strategy, opts, callback;\n   var scope;\n\n   var trace= this.getAuthDetails().trace;\n   var req= this;\n\n   //ughhh pull this rubbish somewhere tidy...\n   if( strategy && opts && callback ) {\n     var type= typeof strategy;\n     if(  strategy.constructor != Array ) {\n       strategy= [strategy]\n     }\n     scope= opts.scope;\n   }\n   else if( strategy && opts ) {\n     callback= opts;\n     var type= typeof strategy;\n     if( strategy.constructor == Array ) {\n       // do nothing\n     }\n     else if( type == 'string' ) {\n       strategy= [strategy];\n     }\n     else if( type == 'object') {\n       scope= strategy.scope\n       strategy= undefined;\n     }\n   }\n   else if( strategy ) {\n     callback= strategy;\n     strategy= undefined;\n   }\n   // Choose the first strategy defined if no strategy provided\n   if( !strategy && strategyExecutor.strategies ) {\n     for( var k in strategyExecutor.strategies ) {\n       strategy= [strategyExecutor.strategies[k].name];\n       break;\n     }\n   }\n\n   // Sometimes the authentication scope needs to passed between requests, we store this information\n   // transiently on the session.\n   if( scope === undefined && req.getAuthDetails().__performingAuthentication && req.getAuthDetails().__originalScope ) {\n     scope= req.getAuthDetails().__originalScope;\n   }\n\n   trace( \"Authenticating (\"+this.headers.host + this.originalUrl+\")\", scope, \">>>\" );\n   if( req.isAuthenticated(scope) ) {\n     delete req.getAuthDetails().__performingAuthentication;\n     delete req.getAuthDetails().__originalUrl;\n     delete req.getAuthDetails().__originalScope;\n     trace( \"Authentication successful (Already Authenticated)\", scope, \"<<<\" );\n     callback(null, true);\n   }\n   else {\n     var authContext= {scope:scope, request:req, response:res};\n     strategyExecutor.authenticate(strategy, authContext, function (error, executionResult) {\n       //TODO: This needs tidying up, the HTTP strategies have bled...\n       if( executionResult) {\n         req.getAuthDetails().errorResponse= executionResult.errorResponse;\n         if( req.getAuthDetails().__originalUrl ) {\n           executionResult.originalUrl= req.getAuthDetails().__originalUrl;\n         } else {\n           executionResult.originalUrl= req.originalUrl;\n         }\n       }\n       if(error) {\n         delete req.getAuthDetails().__performingAuthentication;\n         delete req.getAuthDetails().__originalUrl;\n         delete req.getAuthDetails().__originalScope\n         trace( \"Authentication error: \"+ error, scope, \"<<<\" );\n         callback(error);\n       }\n       else {\n         if( executionResult.authenticated === true ) {\n           trace( \"Authentication successful\", scope, \"<<<\" );\n           executionResult.originalUrl= req.getAuthDetails().__originalUrl;\n           delete req.getAuthDetails().__originalUrl;\n           delete req.getAuthDetails().__originalScope\n\n           if( scope === undefined) {\n            req.getAuthDetails().user= executionResult.user;\n           }\n           else {\n             if( req.getAuthDetails().scopedUsers[scope] === undefined ) {\n              req.getAuthDetails().scopedUsers[scope] = {};\n             }\n             req.getAuthDetails().scopedUsers[scope].user=  executionResult.user;\n           }\n\n           if( req.getAuthDetails().__performingAuthentication ) {\n             try {\n               delete req.getAuthDetails().__performingAuthentication;\n               trace( \"Firing 'FirstLogin' Handler\", scope, \"$$$\" );\n               firstLoginHandler( authContext, executionResult, callback );\n             }\n             catch(err) {\n               trace( \"error: With executing firstLoginHandler\" + err.stack );\n             }\n           }\n           else  {\n             callback(null, executionResult.authenticated)\n           }\n         }\n         else if( executionResult.authenticated === false ) {\n           delete req.getAuthDetails().__performingAuthentication;\n           delete req.getAuthDetails().__originalUrl;\n           delete req.getAuthDetails().__originalScope;\n           trace( \"Authentication failed\", scope, \"<<<\" );\n           callback(null, executionResult.authenticated)\n         }\n         else {\n           req.getAuthDetails().__performingAuthentication= true;\n           req.getAuthDetails().__originalUrl= req.originalUrl;\n           req.getAuthDetails().__originalScope= scope;\n           trace( \"Authentication ongoing (Requires browser interaction)\", scope, \"<<<\" );\n           callback(null, executionResult.authenticated)\n         }\n       }\n     });\n   }\n};\n\n // mixins...\nmodule.exports.getAuthDetails= function() {\n   return this._connect_auth\n};\n\nmodule.exports.isAuthenticated= function(scope) {\n   if( scope === undefined ) {\n     return (this.getAuthDetails().user) ? true : false;\n   }\n   else {\n     return (this.getAuthDetails().scopedUsers[scope] && this.getAuthDetails().scopedUsers[scope].user) ? true : false;\n   }\n};\n\nmodule.exports.isUnAuthenticated= function(scope) {\n   return !this.isAuthenticated( scope );\n};\n\nmodule.exports.logout= function( authContext, logoutHandler, middlewareCallback ) {\n   var ad= this.getAuthDetails();\n   ad.trace( \"Logout\", authContext.scope, \"!!!\" );\n   var user;\n   if( authContext.scope === undefined) {\n     user= ad.user;\n     delete ad.user;\n     ad.scopedUsers= {};\n   }\n   else {\n     user= ad.scopedUsers[authContext.scope].user;\n     delete ad.scopedUsers[authContext.scope].user;\n   }\n   logoutHandler( authContext, user, middlewareCallback );\n};"]],"start1":0,"start2":0,"length1":0,"length2":6016}]],"length":6016}
{"contributors":[],"silentsave":false,"ts":1350573025173,"patch":[[{"diffs":[[0,"  }\n\n   "],[1,"//"],[0,"trace( \""]],"start1":1811,"start2":1811,"length1":16,"length2":18}]],"length":6018,"saved":false}
{"ts":1350573184933,"patch":[[{"diffs":[[0,"Scope;\n     "],[1,"//"],[0,"trace( \"Auth"]],"start1":2095,"start2":2095,"length1":24,"length2":26}]],"length":6020,"saved":false}
